<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Web Arcade - Game</title>
  <link rel="stylesheet" href="/styles.css" />
  <link rel="icon" href="data:," />
</head>
<body>
  <div class="wrap" style="align-items:flex-start;">
    <div class="card">
      <div class="hrow">
        <div>
          <h1 id="title">Game</h1>
          <div class="small" id="desc"></div>
        </div>
        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <button class="btn" id="backBtn">í—ˆë¸Œë¡œ</button>
          <button class="btn" id="restartBtn">ì¬ì‹œì‘</button>
        </div>
      </div>

      <div class="grid">
        <div class="panel">
          <h2>í”Œë ˆì´</h2>
          <div class="gamebox"><canvas id="c"></canvas></div>
          <div class="msg" id="msg"></div>
          <div class="small" id="hud"></div>
          <div class="small" id="extra"></div>
        </div>

        <div class="panel">
          <h2>ë„ì›€ë§</h2>
          <div class="small" id="help"></div>
          <hr style="border:0;border-top:1px solid rgba(255,255,255,0.10); margin:12px 0;">
          <div class="small">
            ì¢…ë£Œ ì‹œ ê²°ê³¼ê°€ í—ˆë¸Œë¡œ ì „ë‹¬ë˜ì–´ ëˆ„ì  Score/Coinsê°€ ê°±ì‹ ë©ë‹ˆë‹¤.
          </div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

    const SUPABASE_URL = "https://jwkjsmlicirmuujsmdfi.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable_YfPtLavytOMWG5gHr7pEDg_Dy3j8Wld";

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true,
        storage: localStorage,
      }
    });

    const titleEl = document.getElementById("title");
    const descEl = document.getElementById("desc");
    const msgEl = document.getElementById("msg");
    const hudEl = document.getElementById("hud");
    const extraEl = document.getElementById("extra");
    const helpEl = document.getElementById("help");
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    document.getElementById("backBtn").onclick = () => location.href = "/index.html";
    document.getElementById("restartBtn").onclick = () => start();

    function setMsg(t, ok=false){ msgEl.className="msg "+(ok?"ok":"err"); msgEl.textContent=t||""; }
    function rand(a,b){ return a + Math.random()*(b-a); }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function dist(x1,y1,x2,y2){ return Math.hypot(x1-x2, y1-y2); }

    // âœ… íŠ•ê¹€ ë°©ì§€
    async function requireSession(){
      let s = await supabase.auth.getSession();
      if(!s.data?.session){
        await new Promise(r=>setTimeout(r, 400));
        s = await supabase.auth.getSession();
      }
      if(!s.data?.session){
        location.href = "/index.html";
        throw new Error("No session");
      }
      return s.data.session;
    }
    await requireSession();

    // ë¡œì»¬ ì½”ì¸
    const LS_COINS = "arcade_total_coins_v3";
    function getCoins(){ return Number(localStorage.getItem(LS_COINS)||"200")||200; }

    const qs = new URLSearchParams(location.search);
    const g = qs.get("g") || "dodge";

    const RULES = {
      dodge:  { winS: 40, loseS: -15, winC: 10, loseC: -5 },
      clicker:{ winS: 30, loseS: -10, winC: 5,  loseC: -3 },
      aim:    { winS: 35, loseS: -12, winC: 8,  loseC: -4 },
      rhythm: { winS: 55, loseS: -20, winC: 12, loseC: -6 },
      puzzle: { winS: 60, loseS: -25, winC: 15, loseC: -8 },
      tetris: { winS: 70, loseS: -30, winC: 18, loseC: -10 },
      slot:   { winS: 10, loseS: -5,  winC: 0,  loseC: 0 },
    };

    function end(result, ds, dc){
      cancelAnimationFrame(raf);
      setMsg(result==="win" ? "WIN! í—ˆë¸Œë¡œ ëŒì•„ê°‘ë‹ˆë‹¤." : "LOSE! í—ˆë¸Œë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.", result==="win");
      setTimeout(()=>{
        location.href = `/index.html?result=${result}&g=${encodeURIComponent(g)}&ds=${encodeURIComponent(ds)}&dc=${encodeURIComponent(dc)}`;
      }, 650);
    }

    function resize(){
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    addEventListener("resize", resize);

    const key = { left:false,right:false,up:false,down:false, space:false };
    addEventListener("keydown", (e)=>{
      if (e.code==="ArrowLeft"||e.code==="KeyA") key.left=true;
      if (e.code==="ArrowRight"||e.code==="KeyD") key.right=true;
      if (e.code==="ArrowUp"||e.code==="KeyW") key.up=true;
      if (e.code==="ArrowDown"||e.code==="KeyS") key.down=true;
      if (e.code==="Space") key.space=true;
    });
    addEventListener("keyup", (e)=>{
      if (e.code==="ArrowLeft"||e.code==="KeyA") key.left=false;
      if (e.code==="ArrowRight"||e.code==="KeyD") key.right=false;
      if (e.code==="ArrowUp"||e.code==="KeyW") key.up=false;
      if (e.code==="ArrowDown"||e.code==="KeyS") key.down=false;
      if (e.code==="Space") key.space=false;
    });

    let lastClick = { x:0, y:0, hit:false };
    canvas.addEventListener("click", (ev)=>{
      const rect = canvas.getBoundingClientRect();
      lastClick = { x: ev.clientX-rect.left, y: ev.clientY-rect.top, hit:true };
    });

    let state = null;
    let raf = 0;
    let last = 0;

    function loop(now){
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;
      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;

      const result = state.step(dt, w, h);
      state.draw(w, h);

      if(result){
        if(g === "slot"){
          return end(result.result, result.ds, result.dc);
        }else{
          const r = RULES[g] || RULES.dodge;
          const ds = (result === "win") ? r.winS : r.loseS;
          const dc = (result === "win") ? r.winC : r.loseC;
          return end(result, ds, dc);
        }
      }
      raf = requestAnimationFrame(loop);
    }

    function makeDodge(){
      titleEl.textContent = "Dodge";
      descEl.textContent = "10ì´ˆ ìƒì¡´í•˜ë©´ WIN. WASD/ë°©í–¥í‚¤ ì´ë™.";
      helpEl.innerHTML = "ì¥ì• ë¬¼ì„ í”¼í•˜ë©´ì„œ 10ì´ˆ ë²„í‹°ì„¸ìš”.";
      return {
        t:0, duration:10,
        p:{ x:0, y:0, r:14 },
        balls:[],
        step(dt,w,h){
          this.t += dt;
          const p=this.p;
          if(this.t===dt){ p.x=w*0.5; p.y=h*0.78; }
          const spd=260;
          const dx=(key.left?-1:0)+(key.right?1:0);
          const dy=(key.up?-1:0)+(key.down?1:0);
          p.x = clamp(p.x+dx*spd*dt, p.r, w-p.r);
          p.y = clamp(p.y+dy*spd*dt, p.r, h-p.r);

          if(Math.random()<2.2*dt) this.balls.push({ x:rand(20,w-20), y:-20, r:rand(10,18), vy:rand(140,260) });
          for(const b of this.balls) b.y += b.vy*dt;
          this.balls = this.balls.filter(b=> b.y < h+30);
          for(const b of this.balls) if(dist(b.x,b.y,p.x,p.y) < b.r+p.r) return "lose";
          if(this.t>=this.duration) return "win";
          hudEl.textContent = `ë‚¨ì€ ì‹œê°„ ${(this.duration-this.t).toFixed(1)}s`;
          extraEl.textContent = "";
          return null;
        },
        draw(w,h){
          ctx.fillStyle="#091022"; ctx.fillRect(0,0,w,h);
          ctx.fillStyle="rgba(120,200,255,0.95)";
          ctx.beginPath(); ctx.arc(this.p.x,this.p.y,this.p.r,0,Math.PI*2); ctx.fill();
          ctx.fillStyle="rgba(255,120,180,0.92)";
          for(const b of this.balls){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }
        }
      };
    }

    function makeClicker(){
      titleEl.textContent="Clicker";
      descEl.textContent="8ì´ˆ ì•ˆì— 25ë²ˆ í´ë¦­í•˜ë©´ WIN.";
      helpEl.innerHTML="ìº”ë²„ìŠ¤ë¥¼ ë¹ ë¥´ê²Œ í´ë¦­í•˜ì„¸ìš”.";
      return {
        t:0, duration:8, goal:25, clicks:0,
        step(dt){
          this.t += dt;
          if(lastClick.hit){ this.clicks++; lastClick.hit=false; }
          hudEl.textContent = `Clicks ${this.clicks}/${this.goal} Â· ë‚¨ì€ ${(this.duration-this.t).toFixed(1)}s`;
          extraEl.textContent = "";
          if(this.clicks>=this.goal) return "win";
          if(this.t>=this.duration) return "lose";
          return null;
        },
        draw(w,h){
          ctx.fillStyle="#0a1126"; ctx.fillRect(0,0,w,h);
          const p = clamp(this.clicks/this.goal,0,1);
          ctx.fillStyle="rgba(120,200,255,0.22)"; ctx.fillRect(30,h*0.55,(w-60)*p,18);
          ctx.strokeStyle="rgba(255,255,255,0.18)"; ctx.strokeRect(30,h*0.55,w-60,18);
          ctx.fillStyle="rgba(233,238,252,0.95)"; ctx.font="20px system-ui";
          ctx.fillText(`Clicks: ${this.clicks}/${this.goal}`, 30, h*0.45);
        }
      };
    }

    function makeAim(){
      titleEl.textContent="Aim";
      descEl.textContent="10ì´ˆ ì•ˆì— 8ê°œ íƒ€ê²Ÿ í´ë¦­í•˜ë©´ WIN.";
      helpEl.innerHTML="ë…¸ë€ íƒ€ê²Ÿì„ í´ë¦­í•˜ì„¸ìš”.";
      return {
        t:0, duration:10, goal:8, hits:0, target:null,
        spawn(w,h){ this.target = { x:rand(60,w-60), y:rand(70,h-70), r:rand(18,28) }; },
        step(dt,w,h){
          if(!this.target) this.spawn(w,h);
          this.t += dt;
          if(lastClick.hit){
            const {x,y} = lastClick; lastClick.hit=false;
            if(dist(x,y,this.target.x,this.target.y) <= this.target.r){
              this.hits++;
              this.spawn(w,h);
            }
          }
          hudEl.textContent = `Hits ${this.hits}/${this.goal} Â· ë‚¨ì€ ${(this.duration-this.t).toFixed(1)}s`;
          extraEl.textContent = "";
          if(this.hits>=this.goal) return "win";
          if(this.t>=this.duration) return "lose";
          return null;
        },
        draw(w,h){
          ctx.fillStyle="#091022"; ctx.fillRect(0,0,w,h);
          ctx.fillStyle="rgba(255,230,80,0.22)";
          ctx.beginPath(); ctx.arc(this.target.x,this.target.y,this.target.r+10,0,Math.PI*2); ctx.fill();
          ctx.fillStyle="rgba(255,230,80,0.55)";
          ctx.beginPath(); ctx.arc(this.target.x,this.target.y,this.target.r,0,Math.PI*2); ctx.fill();
        }
      };
    }

    function makeRhythm(){
      titleEl.textContent="Rhythm";
      descEl.textContent="ì¤‘ì•™ì— ì˜¬ ë•Œ Space! 6ë²ˆ ì„±ê³µ WIN. ì‹¤ìˆ˜ 3ë²ˆ LOSE.";
      helpEl.innerHTML="ë°”ê°€ ì¤‘ì•™ ì˜ì—­ì— ë“¤ì–´ì˜¤ë©´ Spaceë¥¼ ëˆ„ë¥´ì„¸ìš”.";
      return {
        t:0, duration:18, hits:0, miss:0, x:0, vx:420, cooldown:0, can:true,
        step(dt,w,h){
          this.t += dt;
          this.cooldown = Math.max(0, this.cooldown - dt);
          this.x += this.vx*dt;
          if(this.x < 30){ this.x=30; this.vx=Math.abs(this.vx); }
          if(this.x > w-30){ this.x=w-30; this.vx=-Math.abs(this.vx); }
          const center = w*0.5;
          const okZone = Math.abs(this.x-center) < 35;

          if(key.space && this.cooldown<=0){
            this.cooldown = 0.25;
            if(okZone) this.hits++; else this.miss++;
          }
          hudEl.textContent = `Hits ${this.hits}/6 Â· Miss ${this.miss}/3 Â· ë‚¨ì€ ${(this.duration-this.t).toFixed(1)}s`;
          extraEl.textContent = "Spaceë¡œ íŒì •";
          if(this.hits>=6) return "win";
          if(this.miss>=3 || this.t>=this.duration) return "lose";
          return null;
        },
        draw(w,h){
          ctx.fillStyle="#0a1022"; ctx.fillRect(0,0,w,h);
          ctx.fillStyle="rgba(110,255,170,0.10)";
          ctx.fillRect(w*0.5-35, 80, 70, h-160);
          ctx.fillStyle="rgba(255,230,80,0.7)";
          ctx.fillRect(this.x-6, 90, 12, h-180);
          ctx.fillStyle="rgba(255,255,255,0.12)";
          ctx.fillRect(w*0.5-1, 70, 2, h-140);
        }
      };
    }

    function makePuzzle(){
      titleEl.textContent="Puzzle";
      descEl.textContent="4x4 ìŠ¬ë¼ì´ë”© í¼ì¦. ì œí•œì‹œê°„ ë‚´ ì™„ì„± WIN.";
      helpEl.innerHTML="ë¹ˆì¹¸ ì˜† íƒ€ì¼ì„ í´ë¦­í•˜ë©´ ì´ë™í•©ë‹ˆë‹¤.";
      const N=4;
      function isSolved(arr){
        for(let i=0;i<N*N-1;i++) if(arr[i]!==i+1) return false;
        return arr[N*N-1]===0;
      }
      function shuffle(arr){
        for(let i=arr.length-1;i>0;i--){
          const j=Math.floor(Math.random()*(i+1));
          [arr[i],arr[j]]=[arr[j],arr[i]];
        }
      }
      return {
        t:0, duration:55, tiles:[],
        step(dt,w,h){
          this.t += dt;
          if(this.tiles.length===0){
            this.tiles = Array.from({length:N*N}, (_,i)=> (i===N*N-1?0:i+1));
            shuffle(this.tiles);
          }
          if(lastClick.hit){
            const {x,y} = lastClick; lastClick.hit=false;
            const size = Math.min(w,h) * 0.78;
            const ox = (w-size)/2, oy=(h-size)/2;
            const cell = size/N;
            const cx = Math.floor((x-ox)/cell);
            const cy = Math.floor((y-oy)/cell);
            if(cx>=0 && cx<N && cy>=0 && cy<N){
              const idx = cy*N+cx;
              const z = this.tiles.indexOf(0);
              const zx = z%N, zy = Math.floor(z/N);
              if(Math.abs(zx-cx)+Math.abs(zy-cy)===1){
                [this.tiles[idx], this.tiles[z]] = [this.tiles[z], this.tiles[idx]];
              }
            }
          }
          hudEl.textContent = `ë‚¨ì€ ${(this.duration-this.t).toFixed(0)}s`;
          extraEl.textContent = "";
          if(isSolved(this.tiles)) return "win";
          if(this.t>=this.duration) return "lose";
          return null;
        },
        draw(w,h){
          ctx.fillStyle="#091022"; ctx.fillRect(0,0,w,h);
          const size = Math.min(w,h) * 0.78;
          const ox = (w-size)/2, oy=(h-size)/2;
          const cell = size/N;

          ctx.fillStyle="rgba(255,255,255,0.08)";
          ctx.fillRect(ox,oy,size,size);

          ctx.font = "20px system-ui";
          for(let i=0;i<N*N;i++){
            const v=this.tiles[i];
            const x=ox+(i%N)*cell, y=oy+Math.floor(i/N)*cell;
            ctx.strokeStyle="rgba(255,255,255,0.12)";
            ctx.strokeRect(x,y,cell,cell);
            if(v===0) continue;
            ctx.fillStyle="rgba(120,200,255,0.20)";
            ctx.fillRect(x+6,y+6,cell-12,cell-12);
            ctx.fillStyle="rgba(233,238,252,0.95)";
            ctx.fillText(String(v), x+cell/2-6, y+cell/2+7);
          }
        }
      };
    }

    function makeTetris(){
      titleEl.textContent="Tetris (Mini)";
      descEl.textContent="ë¼ì¸ 3ê°œ ì§€ìš°ë©´ WIN. (â†â†’ ì´ë™, â†“ ë“œë, Space íšŒì „)";
      helpEl.innerHTML="ê°„ë‹¨ í…ŒíŠ¸ë¦¬ìŠ¤. ë¼ì¸ 3ê°œ í´ë¦¬ì–´í•˜ë©´ ìŠ¹ë¦¬.";
      const W=10, H=20;
      const shapes = [
        [[1,1,1,1]],
        [[1,1],[1,1]],
        [[0,1,0],[1,1,1]],
        [[1,0,0],[1,1,1]],
        [[0,0,1],[1,1,1]],
        [[0,1,1],[1,1,0]],
        [[1,1,0],[0,1,1]],
      ];
      function rot(m){
        const r=m.length, c=m[0].length;
        const out=Array.from({length:c},()=>Array(r).fill(0));
        for(let y=0;y<r;y++) for(let x=0;x<c;x++) out[x][r-1-y]=m[y][x];
        return out;
      }
      function collide(grid, piece, px, py){
        for(let y=0;y<piece.length;y++){
          for(let x=0;x<piece[0].length;x++){
            if(!piece[y][x]) continue;
            const gx=px+x, gy=py+y;
            if(gx<0 || gx>=W || gy>=H) return true;
            if(gy>=0 && grid[gy][gx]) return true;
          }
        }
        return false;
      }
      function merge(grid, piece, px, py){
        for(let y=0;y<piece.length;y++){
          for(let x=0;x<piece[0].length;x++){
            if(!piece[y][x]) continue;
            const gx=px+x, gy=py+y;
            if(gy>=0) grid[gy][gx]=1;
          }
        }
      }
      function clearLines(grid){
        let cleared=0;
        for(let y=H-1;y>=0;y--){
          if(grid[y].every(v=>v===1)){
            grid.splice(y,1);
            grid.unshift(Array(W).fill(0));
            cleared++;
            y++;
          }
        }
        return cleared;
      }

      return {
        t:0, duration:90,
        grid: Array.from({length:H},()=>Array(W).fill(0)),
        piece:null, px:3, py:-2,
        drop:0, speed:0.7,
        lines:0, dead:false, canRotate:true,
        spawn(){
          this.piece = shapes[Math.floor(Math.random()*shapes.length)].map(row=>row.slice());
          this.px = Math.floor(W/2)-1;
          this.py = -2;
          if(collide(this.grid,this.piece,this.px,this.py)) this.dead=true;
        },
        step(dt,w,h){
          this.t += dt;
          if(!this.piece) this.spawn();

          if(key.left){
            if(!collide(this.grid,this.piece,this.px-1,this.py)) this.px--;
            key.left=false;
          }
          if(key.right){
            if(!collide(this.grid,this.piece,this.px+1,this.py)) this.px++;
            key.right=false;
          }
          if(key.space && this.canRotate){
            this.canRotate=false;
            const p2 = rot(this.piece);
            if(!collide(this.grid,p2,this.px,this.py)) this.piece=p2;
          }
          if(!key.space) this.canRotate=true;

          const spd = key.down ? 0.08 : this.speed;
          this.drop += dt;
          if(this.drop >= spd){
            this.drop = 0;
            if(!collide(this.grid,this.piece,this.px,this.py+1)){
              this.py++;
            }else{
              merge(this.grid,this.piece,this.px,this.py);
              this.lines += clearLines(this.grid);
              this.piece=null;
              if(this.lines>=3) return "win";
            }
          }

          hudEl.textContent = `Lines ${this.lines}/3 Â· ë‚¨ì€ ${(this.duration-this.t).toFixed(0)}s`;
          extraEl.textContent = "â†â†’ ì´ë™, â†“ ë“œë, Space íšŒì „";
          if(this.dead || this.t>=this.duration) return "lose";
          return null;
        },
        draw(w,h){
          ctx.fillStyle="#07101f"; ctx.fillRect(0,0,w,h);
          const size = Math.min(w*0.45, h*0.85);
          const cell = Math.floor(size / H * 1.0);
          const bw = W*cell, bh = H*cell;
          const ox = Math.floor((w-bw)/2), oy = Math.floor((h-bh)/2);

          for(let y=0;y<H;y++){
            for(let x=0;x<W;x++){
              if(this.grid[y][x]){
                ctx.fillStyle="rgba(120,200,255,0.25)";
                ctx.fillRect(ox+x*cell+1, oy+y*cell+1, cell-2, cell-2);
              }else{
                ctx.strokeStyle="rgba(255,255,255,0.05)";
                ctx.strokeRect(ox+x*cell, oy+y*cell, cell, cell);
              }
            }
          }

          if(this.piece){
            ctx.fillStyle="rgba(255,230,80,0.35)";
            for(let y=0;y<this.piece.length;y++){
              for(let x=0;x<this.piece[0].length;x++){
                if(!this.piece[y][x]) continue;
                const gx=this.px+x, gy=this.py+y;
                if(gy<0) continue;
                ctx.fillRect(ox+gx*cell+1, oy+gy*cell+1, cell-2, cell-2);
              }
            }
          }
        }
      };
    }

    // âœ… ìŠ¬ë¡¯: ì‹¬ë³¼/ë²„íŠ¼ ê°„ê²© ê³ ì •
    function makeSlot(){
      titleEl.textContent="Slot (Bet)";
      descEl.textContent="ì½”ì¸ì„ ë°°íŒ…í•´ì„œ ëŠ˜ë¦¬ì„¸ìš”. (Space ë˜ëŠ” SPIN í´ë¦­)";
      helpEl.innerHTML="BET - / BET +ë¡œ ë°°íŒ… ì¡°ì ˆ í›„ SPIN. 3ê°œ ì¼ì¹˜ë©´ ëŒ€ë°•!";
      const symbols = ["ğŸ’","ğŸ‹","ğŸ””","7","â­"];
      let bet = 10;

      function payout(a,b,c){
        if(a===b && b===c){
          if(a==="7") return 12;
          if(a==="â­") return 8;
          return 5;
        }
        if(a===b || b===c || a===c) return 2;
        return 0;
      }

      return {
        reels:["ğŸ‹","ğŸ””","7"],
        step(dt,w,h){
          // í•˜ë‹¨ ë²„íŠ¼ í´ë¦­ ì˜ì—­ ì •í™•íˆ
          if(lastClick.hit){
            const {x,y} = lastClick; lastClick.hit=false;
            if(y > h-110){
              const third = w/3;
              if(x < third) bet = Math.max(1, bet-5);
              else if(x < third*2) bet = Math.min(200, bet+5);
              else return this.spin(bet);
            }
          }
          if(key.space){ key.space=false; return this.spin(bet); }

          hudEl.textContent = `ë³´ìœ  ì½”ì¸: ${getCoins()} Â· ë°°íŒ…: ${bet}`;
          extraEl.textContent = "í•˜ë‹¨ ë²„íŠ¼ í´ë¦­ ë˜ëŠ” Spaceë¡œ SPIN";
          return null;
        },
        spin(betAmount){
          const coins = getCoins();
          if(coins < betAmount){
            setMsg("ì½”ì¸ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. ë°°íŒ…ì„ ì¤„ì´ì„¸ìš”.", false);
            return null;
          }
          const a = symbols[Math.floor(Math.random()*symbols.length)];
          const b = symbols[Math.floor(Math.random()*symbols.length)];
          const c = symbols[Math.floor(Math.random()*symbols.length)];
          this.reels=[a,b,c];

          const mult = payout(a,b,c);
          const winCoins = betAmount * mult;
          const deltaCoins = -betAmount + winCoins;

          const result = (deltaCoins >= 0) ? "win" : "lose";
          const base = RULES.slot;
          const ds = result==="win" ? base.winS : base.loseS;
          const dc = deltaCoins;

          return { result, ds, dc };
        },
        draw(w,h){
          ctx.fillStyle="#0a1022"; ctx.fillRect(0,0,w,h);

          // ë¦´ ë°•ìŠ¤ 3ê°œ ê³ ì • í­
          const boxW = w * 0.18;
          const gap  = w * 0.05;
          const totalW = boxW*3 + gap*2;
          const startX = (w - totalW)/2;
          const boxY = h*0.22;
          const boxH = h*0.28;

          ctx.fillStyle="rgba(255,255,255,0.08)";
          ctx.fillRect(startX-18, boxY-18, totalW+36, boxH+36);

          for(let i=0;i<3;i++){
            const x = startX + i*(boxW+gap);
            ctx.fillStyle="rgba(255,255,255,0.10)";
            ctx.fillRect(x, boxY, boxW, boxH);
            ctx.strokeStyle="rgba(255,255,255,0.14)";
            ctx.strokeRect(x, boxY, boxW, boxH);

            ctx.fillStyle="rgba(233,238,252,0.95)";
            ctx.font = `${Math.floor(boxH*0.55)}px system-ui`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(String(this.reels[i]), x + boxW/2, boxY + boxH/2);
          }

          // í•˜ë‹¨ ë²„íŠ¼ 3ë“±ë¶„
          const barH = 110;
          const barY = h - barH;
          ctx.fillStyle="rgba(255,255,255,0.08)";
          ctx.fillRect(0, barY, w, barH);

          const third = w/3;
          const btnY = barY + 20;
          const btnH = barH - 40;
          const labels = ["BET -", "BET +", "SPIN"];

          for(let i=0;i<3;i++){
            const x = i*third + 16;
            const bw = third - 32;

            ctx.fillStyle="rgba(0,0,0,0.18)";
            ctx.fillRect(x, btnY, bw, btnH);
            ctx.strokeStyle="rgba(255,255,255,0.14)";
            ctx.strokeRect(x, btnY, bw, btnH);

            ctx.fillStyle="rgba(233,238,252,0.95)";
            ctx.font="18px system-ui";
            ctx.textAlign="center";
            ctx.textBaseline="middle";
            ctx.fillText(labels[i], x + bw/2, btnY + btnH/2);
          }

          // reset
          ctx.textAlign = "left";
          ctx.textBaseline = "alphabetic";
        }
      };
    }

    function start(){
      cancelAnimationFrame(raf);
      resize();
      setMsg("ê²Œì„ ì‹œì‘!", true);
      last = performance.now();

      if(g==="dodge") state = makeDodge();
      else if(g==="clicker") state = makeClicker();
      else if(g==="aim") state = makeAim();
      else if(g==="rhythm") state = makeRhythm();
      else if(g==="puzzle") state = makePuzzle();
      else if(g==="tetris") state = makeTetris();
      else state = makeSlot();

      loop(last);
    }

    start();
  </script>
</body>
</html>
