<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebGame</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#070a12; color:#e9eefc; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; }

    #hud {
      position:fixed; left:12px; top:12px; z-index:10;
      display:flex; gap:10px; align-items:flex-start; flex-wrap:wrap;
    }
    .panel {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 10px 12px;
      min-width: 270px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .panel h3 { margin:0 0 8px; font-size:14px; opacity:.95; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    button {
      border:1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      color:#e9eefc;
      padding:8px 10px;
      border-radius:10px;
      cursor:pointer;
      font-weight:800;
      font-size:13px;
    }
    button:hover { background: rgba(255,255,255,0.12); }
    input {
      width: 150px;
      border:1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.25);
      color:#e9eefc;
      padding:8px 10px;
      border-radius:10px;
      outline:none;
      font-size:13px;
    }
    .msg { font-size:12px; opacity:.85; white-space:pre-wrap; line-height:1.4; }
    .err { color:#ff8a8a; }
    .ok  { color:#8dffb3; }
    table { width:100%; border-collapse:collapse; font-size:12px; }
    th, td { padding:6px 6px; border-bottom:1px solid rgba(255,255,255,0.10); text-align:left; }
    th { opacity:.85; }
    .small { font-size:11px; opacity:.7; margin-top:6px; }
  </style>
</head>
<body>
  <div id="hud">
    <div class="panel">
      <h3>상태</h3>
      <div id="status" class="msg"></div>
      <div class="row" style="margin-top:8px;">
        <button id="homeBtn">홈</button>
        <button id="logoutBtn">로그아웃</button>
        <button id="restartBtn">R 재시작</button>
      </div>
      <div class="small">조작: WASD/방향키 이동 · Space 발사</div>
    </div>

    <div class="panel">
      <h3>랭킹 (서버 Top10 + 내 로컬 베스트)</h3>
      <div class="row" style="margin-bottom:8px;">
        <input id="nameInput" placeholder="닉네임(제출용)" maxlength="12" />
        <button id="syncBtn">Sync</button>
        <button id="submitBtn">제출</button>
      </div>
      <div id="msg" class="msg"></div>
      <div id="rank"></div>
    </div>
  </div>

  <canvas id="c"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // =========================
    // ✅ 여기 3개만 네 값으로 정확히 넣기
    // =========================
    const SUPABASE_URL = "https://jwkjsmlicirmuujsmdfi.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable_YfPtLavytOMWG5gHr7pEDg_Dy3j8Wld";
    const FUNCTION_URL = "https://jwkjsmlicirmuujsmdfi.supabase.co/functions/v1/leaderboard";

    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const statusEl = document.getElementById("status");
    const msgEl = document.getElementById("msg");
    const rankEl = document.getElementById("rank");
    const nameInput = document.getElementById("nameInput");

    function setMsg(text, ok=false) {
      msgEl.className = "msg " + (ok ? "ok" : "err");
      msgEl.textContent = text || "";
    }

    // ---- Auth gate ----
    async function requireSession() {
      const { data } = await supabase.auth.getSession();
      const s = data?.session;
      if (!s) {
        location.href = "/index.html";
        return null;
      }
      return s;
    }

    // ---- Local best ----
    const LS_KEY = "webgame_local_best_v1";
    function loadLocalBest() {
      try { return JSON.parse(localStorage.getItem(LS_KEY) || "null"); } catch { return null; }
    }
    function saveLocalBest(entry) {
      localStorage.setItem(LS_KEY, JSON.stringify(entry));
    }

    // ---- Server ----
    let serverTop = [];

    async function callFn(body) {
      const { data } = await supabase.auth.getSession();
      const token = data?.session?.access_token;
      if (!token) throw new Error("No auth session");

      const res = await fetch(FUNCTION_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + token
        },
        body: JSON.stringify(body)
      });

      const j = await res.json().catch(() => ({}));
      if (!res.ok || j.ok === false) throw new Error(j.error || j.message || ("HTTP " + res.status));
      return j;
    }

    async function syncServer() {
      setMsg("서버 랭킹 불러오는 중...");
      try {
        const j = await callFn({ action: "top", limit: 10 });
        serverTop = j.data || [];
        setMsg("서버 랭킹 업데이트 완료", true);
        renderRank();
      } catch (e) {
        setMsg("Sync 실패: " + (e?.message || e));
      }
    }

    async function submitServer(name, score, stage) {
      setMsg("서버에 제출 중...");
      try {
        await callFn({ action: "submit", name, score, stage });
        setMsg("제출 성공! 서버 랭킹 갱신 중...", true);
        await syncServer();
      } catch (e) {
        setMsg("제출 실패: " + (e?.message || e));
      }
    }

    function esc(s){ return String(s).replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m])); }

    function renderRank() {
      const local = loadLocalBest();
      const serverRows = (serverTop || []).map((r, i) => ({
        rank: "#" + (i+1),
        name: r.name,
        score: r.score,
        stage: r.stage,
        time: new Date(r.created_at).toLocaleString()
      }));

      const localRow = local ? [{
        rank: "(Local)",
        name: local.name,
        score: local.score,
        stage: local.stage,
        time: new Date(local.ts).toLocaleString()
      }] : [];

      const rows = [...serverRows, ...(localRow.length ? [{sep:true}] : []), ...localRow];

      rankEl.innerHTML = `
        <table>
          <thead><tr><th>Rank</th><th>Name</th><th>Score</th><th>Stage</th><th>Time</th></tr></thead>
          <tbody>
            ${rows.map(r => r.sep
              ? `<tr><td colspan="5" style="opacity:.5;">— 내 로컬 베스트 —</td></tr>`
              : `<tr><td>${r.rank}</td><td>${esc(r.name)}</td><td>${r.score}</td><td>${r.stage}</td><td>${r.time}</td></tr>`
            ).join("")}
          </tbody>
        </table>
        <div class="small">* 로컬 베스트는 이 브라우저에만 저장됩니다.</div>
      `;
    }

    // ---- Buttons ----
    document.getElementById("homeBtn").onclick = () => location.href = "/index.html";
    document.getElementById("logoutBtn").onclick = async () => { await supabase.auth.signOut(); location.href = "/index.html"; };
    document.getElementById("restartBtn").onclick = () => reset();
    document.getElementById("syncBtn").onclick = syncServer;
    document.getElementById("submitBtn").onclick = async () => {
      const n = (nameInput.value || "").trim().slice(0,12) || "Player";
      await submitServer(n, Math.floor(state.score), state.stage);
    };

    // =========================
    // 게임 (간단 슈팅/회피 베이스)
    // =========================
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    function resize() {
      canvas.width = Math.floor(innerWidth * devicePixelRatio);
      canvas.height = Math.floor(innerHeight * devicePixelRatio);
    }
    addEventListener("resize", resize);
    resize();

    const keys = new Set();
    addEventListener("keydown", (e) => { keys.add(e.code); if (e.code === "KeyR") reset(); });
    addEventListener("keyup", (e) => keys.delete(e.code));

    const state = {
      running: true,
      score: 0,
      stage: 1,
      hp: 3,
      t: 0,
      player: { x: 0.5, y: 0.82, r: 0.02 },
      bullets: [],
      enemies: []
    };

    function reset() {
      state.running = true;
      state.score = 0;
      state.stage = 1;
      state.hp = 3;
      state.t = 0;
      state.player = { x: 0.5, y: 0.82, r: 0.02 };
      state.bullets = [];
      state.enemies = [];
      setMsg("R로 재시작. 게임오버 시 로컬 베스트가 자동 갱신됩니다.", true);
    }

    function spawnEnemy() {
      const x = Math.random();
      const y = -0.06;
      const r = 0.018 + Math.random() * 0.022;
      const spd = 0.18 + Math.random() * 0.18 + state.stage * 0.02;
      state.enemies.push({ x, y, r, spd });
    }

    let shootCD = 0;
    function shoot() {
      const p = state.player;
      state.bullets.push({ x: p.x, y: p.y - p.r, r: 0.008, vy: -0.75 });
    }

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function dist(x1,y1,x2,y2){ return Math.hypot(x1-x2, y1-y2); }

    function step(dt) {
      if (!state.running) return;
      state.t += dt;

      // stage: 점수로 상승
      state.stage = 1 + Math.floor(state.score / 250);

      // 이동
      const p = state.player;
      const spd = 0.6;
      const dx = (keys.has("ArrowLeft")||keys.has("KeyA")?-1:0) + (keys.has("ArrowRight")||keys.has("KeyD")? 1:0);
      const dy = (keys.has("ArrowUp")||keys.has("KeyW")?-1:0) + (keys.has("ArrowDown")||keys.has("KeyS")? 1:0);
      p.x = clamp(p.x + dx * spd * dt, 0.04, 0.96);
      p.y = clamp(p.y + dy * spd * dt, 0.08, 0.96);

      // 발사
      shootCD -= dt;
      if (keys.has("Space") && shootCD <= 0) {
        shoot();
        shootCD = 0.12;
      }

      // 적 스폰
      const rate = 1.1 + state.stage * 0.25;
      if (Math.random() < rate * dt) spawnEnemy();

      // 탄환 업데이트
      for (const b of state.bullets) b.y += b.vy * dt;
      state.bullets = state.bullets.filter(b => b.y > -0.2);

      // 적 업데이트
      for (const e of state.enemies) e.y += e.spd * dt;
      state.enemies = state.enemies.filter(e => e.y < 1.3);

      // 충돌(탄-적)
      for (let i = state.enemies.length - 1; i >= 0; i--) {
        const e = state.enemies[i];
        for (let j = state.bullets.length - 1; j >= 0; j--) {
          const b = state.bullets[j];
          if (dist(e.x,e.y,b.x,b.y) < e.r + b.r) {
            state.enemies.splice(i,1);
            state.bullets.splice(j,1);
            state.score += 12;
            break;
          }
        }
      }

      // 충돌(적-플레이어)
      for (let i = state.enemies.length - 1; i >= 0; i--) {
        const e = state.enemies[i];
        if (dist(e.x,e.y,p.x,p.y) < e.r + p.r) {
          state.enemies.splice(i,1);
          state.hp -= 1;
          if (state.hp <= 0) gameOver();
        }
      }

      // 시간 점수
      state.score += dt * (2.2 + state.stage * 0.5);
    }

    function gameOver() {
      state.running = false;

      // 로컬 베스트 갱신
      const name = (nameInput.value || "").trim().slice(0,12) || "Player";
      const score = Math.floor(state.score);
      const best = loadLocalBest();
      if (!best || score > best.score) {
        saveLocalBest({ name, score, stage: state.stage, ts: Date.now() });
      }

      setMsg("GAME OVER!\n로컬 베스트가 저장(또는 갱신)되었습니다.\n'제출'을 눌러 서버에 올릴 수 있어요.\nR로 재시작", false);
      renderRank();
    }

    function draw() {
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);

      // 배경
      ctx.fillStyle = "#050814";
      ctx.fillRect(0,0,w,h);

      // 약한 격자
      ctx.globalAlpha = 0.08;
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1;
      const stepPx = 90 * devicePixelRatio;
      ctx.beginPath();
      for (let x=0; x<w; x+=stepPx) { ctx.moveTo(x,0); ctx.lineTo(x,h); }
      for (let y=0; y<h; y+=stepPx) { ctx.moveTo(0,y); ctx.lineTo(w,y); }
      ctx.stroke();
      ctx.globalAlpha = 1;

      // HUD 텍스트
      ctx.fillStyle = "rgba(233,238,252,0.95)";
      ctx.font = `${16*devicePixelRatio}px system-ui`;
      ctx.fillText(`Score: ${Math.floor(state.score)}   Stage: ${state.stage}   HP: ${state.hp}`, 16*devicePixelRatio, 26*devicePixelRatio);

      // 정규화 좌표 -> 픽셀
      const toX = x => x * w;
      const toY = y => y * h;
      const toR = r => r * Math.min(w,h);

      // 플레이어
      const p = state.player;
      ctx.fillStyle = "rgba(120,200,255,0.92)";
      circle(toX(p.x), toY(p.y), toR(p.r));

      // 탄환
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      for (const b of state.bullets) circle(toX(b.x), toY(b.y), toR(b.r));

      // 적
      ctx.fillStyle = "rgba(255,120,180,0.9)";
      for (const e of state.enemies) circle(toX(e.x), toY(e.y), toR(e.r));

      // 오버레이
      if (!state.running) {
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(0,0,w,h);
        ctx.fillStyle = "rgba(233,238,252,0.95)";
        ctx.font = `${30*devicePixelRatio}px system-ui`;
        ctx.fillText("GAME OVER", w*0.5 - 95*devicePixelRatio, h*0.5);
        ctx.font = `${14*devicePixelRatio}px system-ui`;
        ctx.fillText("Press R to restart", w*0.5 - 85*devicePixelRatio, h*0.5 + 26*devicePixelRatio);
      }
    }

    function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }

    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;
      step(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // ---- Start ----
    (async () => {
      const s = await requireSession();
      if (!s) return;

      statusEl.textContent =
        `provider: ${s.user?.app_metadata?.provider || "anonymous"}\nuser_id: ${s.user.id}`;

      renderRank();
      setMsg("Sync로 서버 랭킹을 불러오고, 게임오버 후 '제출'로 서버에 올릴 수 있어요.", true);

      reset();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
